'''
Provides Methods to interact with systems
Only MacOS implemented at this stage
when instantiated you will need to grant the python process permissions ot interface with the shell

'''


import platform
import ctypes
from AppKit import NSScreen
import pyautogui
pyautogui.PAUSE = 0.01
import time
import math
import threading
import subprocess

class interaction_model():
    def __init__(self): 
        
        
        self.cursor_state = "IDLE"
        #has states IDLE, CLICK, DRAG
        
        self.spread_flag = 0
        
        self.mouse = CursorController()
        self.mouse.start()
        self.MAC,self.WIN,self.LINUX = False,False,False
        self.display_w = self.display_h = 0
        if platform.system() == "Windows":
            self.WIN = True
            user32 = ctypes.windll.user32
            screensize = user32.GetSystemMetrics(0), user32.GetSystemMetrics(1)
            raise()


        elif platform.system() == "Darwin":
            self.MAC = True
            self.display_w = NSScreen.mainScreen().frame().size.width
            self.display_h = NSScreen.mainScreen().frame().size.height
            
        else:
            self.LINUX = True
            print("cannot HCI linux")
        print(f"Started on display size {self.display_w} x {self.display_h}")
        
        
    def _sigmoid(self, x):
        # Sigmoid function: f(x) = 1 / (1 + e^(-x))
        return 1 / (1 + math.exp(-x))
    def flick_with_velocity(self, yv, xv):
        pass
    def flick_scroll(velocity, duration):

        pyautogui.scroll(velocity)
        time.sleep(duration)
        pyautogui.scroll(-velocity)
    
    def get_display_dimensions(self):
        if self.MAC:
            pass
        pass
    def move_mouse_to(self,x,y):
        pyautogui.moveTo(x, y, _pause=False )

    def pinch(self):
        pass
    
        
    def pinch_down(self):
        pass
    
    def click_release(self):
        pass
    
    def is_dragging(self):
        pass
    def stop_mouse(self):
        
        self.spread_flag = 0
        self.mouse.deceleration_factor = 0.1
    
    def detect_hands(self):
        pass
    def spread(self):
        if self.spread_flag == 1:
            return
        self.spread_flag = 1
        self.mouse.deceleration_factor = 0.1
        if self.MAC:
            self.trigger_mission_control()
    def trigger_mission_control(self):
        '''This snippet is generated by chatgpt'''
        applescript_code = """
        tell application "System Events"
            key code 126 using {control down}  -- 126 is the keycode for F3
        end tell
        """

        subprocess.run(['osascript', '-e', applescript_code])
        
        
        
        
    def move_mouse(self,xv,yv,scale):
        self.mouse.deceleration_factor = 0.9
        xv = xv * scale
        yv = yv*scale
        self.mouse.add_velocities(xv,yv)
    def engage_click(self):
        pyautogui.mouseDown()
    
    def disengage_click(self):
        self.spread_flag = 0
        pyautogui.mouseUp()

import pyautogui
import time
import threading

class CursorController:
    def __init__(self, initial_velocity_x=0, initial_velocity_y=0, fps=60, deceleration_factor=0.9):
        self.velocity_x = initial_velocity_x
        self.velocity_y = initial_velocity_y
        self.initial_velocity_x = initial_velocity_x
        self.initial_velocity_y = initial_velocity_y
        self.fps = fps
        self.deceleration_factor = deceleration_factor
        self.stop_event = threading.Event()
        self.thread = threading.Thread(target=self._move_loop)

    def _move_loop(self):
        while not self.stop_event.is_set():
            target_x = pyautogui.position().x + self.velocity_x
            target_y = pyautogui.position().y + self.velocity_y
            pyautogui.moveTo(target_x, target_y, duration=1/self.fps)
            self.velocity_x *= self.deceleration_factor
            self.velocity_y *= self.deceleration_factor
            # print(self.distance_to_edge_normalized())c
            # time.sleep(1/self.fps)

    def start(self):
        self.thread.start()

    def stop(self):
        self.stop_event.set()
        self.thread.join()
    
    def add_velocities(self, amount_x, amount_y):
        
        self.velocity_x += amount_x
        self.velocity_y += amount_y

    def reset_velocity(self):
        self.velocity_x = self.initial_velocity_x
        self.velocity_y = self.initial_velocity_y


    def distance_to_edge_normalized():
        # Get the position of the mouse cursor
        mouse_x, mouse_y = pyautogui.position()

        # Get the size of the screen
        screen_width, screen_height = pyautogui.size()
        
        # Calculate distances to edges
        distance_top = mouse_y
        distance_bottom = screen_height - mouse_y
        distance_left = mouse_x
        distance_right = screen_width - mouse_x
        
        # Find the minimum distance to any edge
        min_distance = min(distance_top, distance_bottom, distance_left, distance_right)
        
        # Normalize the distance between 0 and 1
        normalized_distance = min_distance / min(screen_width, screen_height)
        
        return normalized_distance
    
    
    def pan_y(self):
        pass
    
    def pan_x(self):
        pass
    
    def pinch(self):
        pass

# Example usage
if __name__ == "__main__":
    controller = CursorController(initial_velocity_x=10, initial_velocity_y=5, fps=60)
    controller.start()

    # Move the cursor for 5 seconds
    time.sleep(5)
    
    # Add velocities
    controller.add_velocities(-40, 200)

    # Move the cursor for another 5 seconds
    time.sleep(5)

    # Reset the velocity
    controller.reset_velocity()

    # Move the cursor for another 5 seconds
    time.sleep(5)

    # Stop the cursor movement
    controller.stop()
